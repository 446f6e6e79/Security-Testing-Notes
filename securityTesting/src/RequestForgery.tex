\section{Request Forgery}
\subsection{HTTP and Cookies introduction}
HTTP is a protocol that only allows communication using \textbf{request} and \textbf{responses}. It's considered \textbf{stateless}, meaning that natively, it doesn't allow to preserve the state of a user.
\\Typically, the \textbf{state} is usually maintained via the use of \textbf{cookies}, sent by the server to the client's browser. They typically contain information to identify the client, but are also used for:
\begin{itemize}
    \item \textbf{Identify and authenticate} the logged on users and the corresponding session;
    \item \textbf{Track} the user actions and navigation;
    \item \textbf{Maintain information} regarding user interaction (ex: item in the shopping cart).
\end{itemize}
Cookies are \textbf{stored in the client-side}. It could be possible to:
\begin{itemize}
    \item \textbf{Predictable information}: attackers may guess session IDs or other values.
    \item \textbf{Compromise or leakage}: confidential data like passwords could be exposed.
    \item \textbf{Long expiration}: cookies may persist too long, increasing risk if stolen.
    \item \textbf{Client-side access}: JavaScript can read/modify cookies if \texttt{HttpOnly} is not set.
    \item \textbf{Interception}: cookies can be stolen through proxy or man-in-the-middle attacks if \texttt{Secure} is not set (i.e., not restricted to HTTPS).
\end{itemize}
\paragraph{Session:}
A session is a frame of \textbf{HTTP} communication in which the user \textbf{data are stored in the server}, instead of the client. The \textbf{session identifiers} are unique numbers, used to \textbf{identify every user}. They link the user with their information on the server. Cookies are often used to share the session identifiers.

\subsection{Session Hijacking}
An authorized user logs into a website, the web server generates and stores in the client a \textbf{session cookie}.
While the user is connected to the website, an attacker can steal their session ID. Now, the attacker can use this piece of information to sign into the website as the authorized user, without being detected.
\paragraph{How?}
There are many ways in which an attacker could steal session IDs:
\begin{itemize}
    \item \textbf{Traffic sniffing}: attackers can \textbf{intercept} HTTP communications between the web server and a client. This is typically defined as a \textbf{Man In the Middle} (MITM) attack and it's only feasible if cookies are sent over using plain HTTP (No HTTPS);
    \item \textbf{Session fixation}: attackers can forge a valid, but unused session ID, and then convince an authenticated user into using that ID. The attacker can then access to the user's session;
    \item \textbf{Malware / Trojan injection}: attacker can use a malware to monitor the user activity and steal data, such as the session IDs;
    \item \textbf{XSS}: attacker can exploit the XSS vulnerability to leak the cookie information;
    \item \textbf{Brute force}: attackers can predict the value of the cookie. 
\end{itemize}
\paragraph{Prevention}
\begin{itemize}
    \item Use \textbf{encrypted} communication channels, to prevent MITM attacks;
    \item Don't pass the session IDs as a URL parameter;
    \item When defining a cookie, this guidelines should be followed:
    \begin{itemize}
        \item Use an \textbf{adequate algorithm} to generate session IDs. They should have an adequate length and randomness;
        \item Set a short \textbf{expiration time};
        \item Set HttpOnly parameter to true (no access in the cookie in the client);
        \item Set Secure to true (cookie is only transmitted via secure channels).
    \end{itemize}
\end{itemize}
\subsection{Cross-Site Request Forgery}
Cross-Site Request Forgery (CSRF) is an attack in which an attacker tricks a victim’s browser into 
sending unauthorized requests to a trusted web application in which the victim is already authenticated. 
\\\\The user is lured into visiting a malicious website through social engineering. 
That malicious website causes the victim’s browser to send crafted requests to the target application. 
These requests inherit the victim’s identity and permissions, allowing the attacker to perform 
actions on behalf of the victim (i.e., changing account settings, performing transactions). 
\\\\In this attack, the victim is effectively used as a proxy between the attacker and the web server. It's typically used to perform legitimate, but unauthorized actions on the legitimate user account.
\paragraph{Fixing CSRF}
\textbf{Anti-CSRF token} is a secure, random value generated by the server and inserted into forms or requests to prevent unauthorized actions. The basic idea is that, for every sensitive action, 
the server must verify that the request was intentionally generated by the authenticated user 
and not by an attacker.
\\Also, we could possibly protect this type of actions by prompting another login form. This way, only the authorized user can access those pages.

\subsection{Server-Side Request Forgery}
SSRF attack involves an attacker who can \textbf{abuse server functionality} access or modify resources. 
\begin{itemize}
    \item An attacker can send a request from the backend of the software, to another server;
    \item The server that receives the request believes that the request came from the application, and it's legitimate;
\end{itemize}
It's based on the existence of a trust relation between the servers and of a vulnerability, that allows attackers to abuse such trust relation. The attacker uses the server as a proxy to access data stored in the same server, but not accessible by common users.
\paragraph{Example}
An application queries a server-internal service to obtain current weather forecasts. The application passes a URL containing the API request from the browser to the server.
\begin{verbatim}
POST /forecasts HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 250

weatherApi=http://weatherapp.com/forecasts/
check%3FcurrentDateTime%3D6%26cityId%3D1
\end{verbatim}
This causes the server to make a request to the specified external URL, retrieve the weather forecast, and return the information to the user.
\\\\An attacker can modify the request to specify a URL that points to a local resource on the server itself.
\begin{verbatim}
POST /forecasts HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 1100

weatherApi=http://localhost/admin
\end{verbatim}
The server, executing the request internally, accesses the URL \texttt{http://localhost/admin}. This may cause the server to expose sensitive information (i.e., configuration files or admin panels) that are normally inaccessible from outside. Because the request is executed from within the trusted, it bypasses traditional access controls and security boundaries.
\paragraph{Identification}
To identify this type of issues, it's important to understand how data flows. Determine how user-supplied input (i.e., URL parameters) is propagated to server-side components that perform outbound connections.
\\To discover this type of issue this methods can be applied:
\begin{itemize}
        \item \textbf{Spider the web:} crawl the application to find forms, endpoints and parameters that may accept URLs.
        \item \textbf{Search requests for URL-like parameters:} look for parameter names such as \texttt{url} or \texttt{=http}.
        \item \textbf{Inject SSRF payloads:} submit controlled URLs (i.e., pointing to an attacker-controlled domain) and inspect the server’s behavior and responses.
    \end{itemize}
\paragraph{Mitigation}
\begin{itemize}
    \item \textbf{Validate} request and response also from \textbf{internal services};
    \item \textbf{Add authentication} also for internal and third-party services that don't have it by default;
    \item Have a \textbf{whitelist} of IP addresses allowed to do internal requests;
\end{itemize}