\section{Exercises}

\subsection{Static Taint Analysis}
Consider the following code snippet:
\begin{lstlisting}[language=PHP]
<?php
    $userid = $_GET['userid'];
    $passwd = $_GET['passwd'];
    $passwd = addslashes($passwd);
    echo $passwd;
    $query = "SELECT * FROM users WHERE userid = '$userid' AND passwd = '$passwd'";
    $result = mysql_query($query);
?>
\end{lstlisting}
\begin{enumerate}
    \item First, we can build the CFG for the program. We create one node for each statement and connect them based on the control flow of the program.
    \item Next, we compute the \textbf{Gen} and \textbf{Kill} sets for each node;
    \item Then, we iteratively compute the \textbf{In} and \textbf{Out} sets for each node until no further changes occur;
    \item Finally, we check if any tainted variable reaches a sink without being sanitized.
\end{enumerate}
\paragraph{Step 1: CFG}
The CFG for the above code snippet can be represented as a line of nodes, where each node corresponds to a statement in the code.
Since no control flow statements (like conditionals or loops) are present, the CFG is straightforward.

\paragraph{Step 2: Gen and Kill sets}
We can compute the \textbf{Gen} and \textbf{Kill} sets for each node remembering the definitions from the Taint Analysis section:
\begin{itemize}
    \item $Gen(n)$: the set of variables that are tainted at node $n$;
    \item $Kill(n)$: the set of variables that are untainted at node $n$;
\end{itemize}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Node} & \textbf{Gen[n]} & \textbf{Kill[n]} \\
    \hline
    1 & \{\$userid\} & \{\} \\
    2 & \{\$passwd\} & \{\} \\
    3 & \{\} & \{\$passwd\} \\
    4 & \{\} & \{\} \\
    5 & \{\} & \{\} \\
    6 & \{[\$userid = T $\lor$ \$passwd = T]\$query\} & \{[\$userid = T $\land$ \$passwd = T]\$query\} \\
    7 & \{[\$query=T]\$result\} & \{[\$query=F]\$result\} \\
    \hline
    \end{tabular}
    \caption{Gen and Kill sets for each node in the CFG}
\end{table}
We can see that at node 6, the taint status of the variable \texttt{\$query} is tainted if either \texttt{\$userid} or \texttt{\$passwd} is tainted. 
\paragraph{Step 3: In and Out sets}
We can now iteratively compute the \textbf{In} and \textbf{Out} sets for each node using the data flow equations:
\begin{itemize}
    \item $In[n] = \cup_{p\in pred(n)}Out(p)$
    Defined as the union of all outgoing taint sets from predecessor nodes;
    \item $Out[n] = Gen[n] \cup (In[n] \setminus Kill[n])$
    Defined as the union of the generated taint set at node $n$ and the incoming taint set minus the killed taint set (variables untainted) at node $n$.
    It's important to note that if two or more edges converge into a single node, and a variable is tainted on at least one of those edges, 
    it is considered tainted in the In set of the converging node, even if it was killed on other edges.
\end{itemize}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Node} & \textbf{In[n]} & \textbf{Out[n]} \\
    \hline
    1 & \{\} & \{\$userid\} \\
    2 & \{\$userid\} & \{\$userid, \$passwd\} \\
    3 & \{\$userid, \$passwd\} & \{\$userid\} \\
    4 & \{\$userid\} & \{\$userid\} \\
    5 & \{\$userid\} & \{\$userid\} \\
    6 & \{\$query\} & \{\$query\} \\
    7 & \{\$query, \$userid\} & \{\$result, \$query, \$userid\} \\
    \hline
    \end{tabular}
    \caption{In and Out sets for each node in the CFG}
\end{table}
Note that, if the CFG has no cycles, as in this case, the computation will converge in a single pass.
Otherwise, multiple iterations would be needed until the In and Out sets stabilize.
\paragraph{Step 4: Check for vulnerabilities}
Finally, we check if any tainted variable reaches a sink without being sanitized.
In this case, we can see that at node 6, the variable \texttt{\$query} is tainted because it depends on the tainted variable \texttt{\$userid}.
We also have that \texttt{\$query} is used in a sink (the SQL query execution) without being sanitized.
Therefore, we can conclude that there is a potential SQL injection vulnerability in the code snippet due to the tainted variable \texttt{\$userid} reaching the sink without sanitization.
\paragraph{Important}
When considering the taint status of variables after being sanitized, we must ensure that the sanitization function effectively removes all the taint for the specific vulnerability.
For example, in this case, the function \texttt{addslashes()} is used to sanitize \texttt{\$passwd}. 
It is effective against \textit{SQL Injection} attacks, but it does not affect the taint status in case of other vulnerabilities, such as \textit{Cross-Site Scripting} (XSS).

\subsection{Test Coverage}
The exercise consists in calculating the code coverage for a set of test cases, given a code snippet.
For example, consider the following code snippet:
\label{lst:statement_coverage_example}
\begin{lstlisting}[language=C]
    if((a==0) || (b==0)){
        *res = 0;
        return 1;
    } else if(a==1){
        *res = b;
        return 1;
    } else if(b==1){
        *res = a;
        return 1;
    }
    *res = a*b;
    return 1;
\end{lstlisting}
The test cases provided are:
\begin{enumerate}
    \item \textbf{INPUT}: a=0, b=0; \textbf{EXPECTED OUTPUT}: 0
    \item \textbf{INPUT}: a=0, b=1; \textbf{EXPECTED OUTPUT}: 0
    \item \textbf{INPUT}: a=1, b=3; \textbf{EXPECTED OUTPUT}: 3
    \item \textbf{INPUT}: a=2, b=1; \textbf{EXPECTED OUTPUT}: 2
    \item \textbf{INPUT}: a=2, b=2; \textbf{EXPECTED OUTPUT}: 4
\end{enumerate}
We can now compute all the coverage criteria described in the Dynamic Analysis chapter.

\subsubsection*{Statement coverage}
Statement coverage aims at ensuring that all possible statements in the code are executed at least once during testing.
For a single test case, it is defined as:
\[\text{coverage}=\frac{\text{executed statements}}{\text{total statements}} \cdot 100\]
In the given code snippet, there are a total of 11 statements. 
For each test case, we can track which statements are executed and compute the coverage.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Test Case & a & b & res & coverage\% \\
        \hline
        1 & 0 & 0 & 0 & 27\% \\
        \hline
        2 & 0 & 1 & 0 & 27\% \\
        \hline
        3 & 1 & 3 & 3 & 36\% \\
        \hline
        4 & 2 & 1 & 2 & 45\% \\
        \hline
        5 & 2 & 2 & 4 & 45\% \\
        \hline
    \end{tabular}
    \caption{Test cases for statement coverage}
\end{table}
We can see that test case 2 covers no new statements compared to test case 1, so it can be removed from the suite.
For example, test case 3 covers the statements on line 1,4,5,6, resulting in 4 out of 11 statements being covered, which gives a coverage of 36\%.
\\\\Given the full test suite, we can also compute:
\begin{itemize}
    \item \textbf{Total suite coverage}: considering all test cases together, we can see which statements are covered. In our case,
    we cover all statements, resulting in a total coverage of 100\%;
    \item \textbf{Additional suite coverage}: we can compute the additional coverage following this procedure:
    \begin{enumerate}
        \item Rank the test cases based on their individual coverage, select the one with the highest coverage first;
        \item Compute the additional coverage provided by the selected test case;
        \item Select the next test case that provides the highest additional coverage, and repeat until all test cases are selected.
    \end{enumerate}
\end{itemize}

\subsubsection*{Decision coverage}
In decision coverage, we want to ensure that all possible outcomes of all boolean expressions are executed at least once during testing.
It is defined as:
\[\text{coverage}=\frac{\text{executed decision outcomes}}{\text{total decision outcomes}} \cdot 100\]
In the given code snippet, there are a three decision points, each with two possible outcomes (true and false), resulting in a total of 6 decision outcomes.
For each test case, we can track which decision outcomes are executed and compute the coverage.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Test Case & a & b & res & coverage\% \\
        \hline
        1 & 0 & 0 & 0 & 16.6\% \\
        \hline
        2 & 0 & 1 & 3 & 33.3\% \\
        \hline
        3 & 2 & 1 & 2 & 50\% \\
        \hline
        4 & 2 & 2 & 4 & 50\% \\
        \hline
    \end{tabular}
\end{table}
For example, test case 2 covers $D_1=F$ and $D_2=T$, resulting in 2 out of 6 decision outcomes being covered, which gives a coverage of 33.3\%.
\\\\To compute the full suite coverage metrics, we can create a table of all decision outcomes and mark which ones are covered by the test cases:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Decision Point & True & False \\
        \hline
        $D_1$ & $T_1$ & $T_2, T_3, T_4$ \\
        \hline
        $D_2$ & $T_2$ & $T_3, T_4$ \\
        \hline
        $D_3$ & $T_3$ & $T_4$ \\
        \hline
    \end{tabular}
\end{table}
\begin{itemize}
    \item \textbf{Total suite coverage}: from the table, we can see that all decision outcomes are covered by the test cases, resulting in a total coverage of 100\%;
    \item \textbf{Additional suite coverage}: From the computed table, we can identify the additional coverage provided by each test case.
    It's important to note that each decision outcome has to be covered only once.
\end{itemize}
Given the computed table, we can see that:
\begin{itemize}
    \item $T_4$ covers 3 additional decision outcomes: $D_1=F$, $D_2=F$, $D_3=F$. Its additional coverage is:
    \[\text{coverage}=\frac{3}{6} \cdot 100 = 50\%\]
    \item We still need to cover all the $True$ outcomes. Since every test case covers only one $True$ outcome, we can select one test case arbitrarly.
    \item For example, we can select $T_3$ which covers $D_3=T$. Its additional coverage is:
    \[\text{coverage}= \left(\frac{3}{6} + \frac{1}{3}\right) \cdot 100 = 66.7\%\]
    \item We can repeat the same for $T_2$ and $T_1$, resulting in a final additional coverage of 100\%.
\end{itemize}

\subsubsection*{Condition Coverage}
Similar to decision coverage, condition coverage aims at ensuring that all possible outcomes of all individual boolean conditions within decision points are executed at least once during testing.
It is defined as:
\[\text{coverage}=\frac{\text{executed condition outcomes}}{\text{total condition outcomes}} \cdot 100\]
In the given code snippet, there are a total of 4 individual conditions. Thus, there are 8 possible condition outcomes (true and false for each condition).
For each test case, we can track which condition outcomes are executed and compute the coverage.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Test Case & a & b & res & coverage\% \\
        \hline
        1 & 0 & 0 & 0 & 12.25\% \\
        \hline
        2 & 1 & 3 & 3 & 37.5\% \\
        \hline
        3 & 2 & 1 & 2 & 50\% \\
        \hline
        4 & 2 & 2 & 4 & 50\% \\
        \hline
        5 & 1 & 0 & 0 & 25\% \\
        \hline
    \end{tabular}
\end{table}
For example, test case 2 covers conditions $(a==0)=F$, $(b==0)=F$ and $(a==1)=T$, resulting in 3 out of 8 condition outcomes being covered, which gives a coverage of 37.5\%.
\\\\To compute the full suite coverage metrics, similarly to decision coverage, we can create a table of all condition outcomes and mark which ones are covered by the test cases:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Condition & True & False \\
        \hline
        $(a==0)$ & $T_1$ & $T_2, T_3, T_4, T_5$ \\
        \hline
        $(b==0)$ & $T_5$ & $T_2, T_3, T_4$ \\
        \hline
        $(a==1)$ & $T_2$ & $T_3, T_4$ \\
        \hline
        $(b==1)$ & $T_3$ & $T_4$ \\
        \hline
    \end{tabular}
    \end{table}
\begin{itemize}
    \item \textbf{Total suite coverage}: from the table, we can see that all condition outcomes are covered by the test cases, resulting in a total coverage of 100\%;
    \item \textbf{Additional suite coverage}: is computed similarly to decision coverage.
\end{itemize}

\subsubsection*{Branch coverage}
To compute branch coverage, we first need to identify all the edges in the control flow graph (CFG) of the code snippet.
The CFG for the given code snippet can be represented as follows:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../../images/branch-coverage.png}
    \caption{Control Flow Graph for branch coverage}
\end{figure}
In the CFG, we can identify a total of 10 edges. For each test case, we can track which edges are executed and compute the coverage.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Test Case & a & b & res & coverage\% \\
        \hline
        1 & 0 & 0 & 0 & 20\% \\
        \hline
        2 & 1 & 3 & 3 & 30\% \\
        \hline
        3 & 2 & 1 & 2 & 40\% \\
        \hline
        4 & 2 & 2 & 4 & 40\% \\
        \hline
    \end{tabular}
\end{table}
For example, test case 2 covers nodes 1, 4, 5, 6 so it covers edges (1,4), (4,5), (5,6). We cover 3 out of 10 edges, resulting in a coverage of 30\%.
\\\\To compute the full suite coverage metrics, we can create a table of all edges and mark which ones are covered by the test cases:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Edge & Covered by Test Cases \\
        \hline
        (1,2) & $T_1$ \\
        \hline
        (2,3) & $T_1$ \\
        \hline
        (1,4) & $T_2, T_3, T_4$ \\
        \hline
        (4,5) & $T_2$ \\
        \hline
        (5,6) & $T_2$ \\
        \hline
        (4,7) & $T_3, T_4$ \\
        \hline
        (7,8) & $T_3$ \\
        \hline
        (8,9) & $T_3$ \\
        \hline
        (7,10) & $T_4$ \\
        \hline
        (10,11) & $T_4$ \\
        \hline
    \end{tabular}
\end{table}
\begin{itemize}
    \item \textbf{Total suite coverage}: from the table, we can see that all edges are covered by the test cases, resulting in a total suite coverage of 100\%;
    \item \textbf{Additional suite coverage}: also in this case, it is computed similarly to decision coverage.
\end{itemize}

\subsection{Mutation Testing}
For this exercise, we are usually given a code snippet, a set of test case and a set of mutants.
The goal is to determine which mutants are killed by the test cases.
A mutant is considered killed if at least one test case fails when executed against the mutant.
Consider the following code snippet:
\begin{figure}[H]
    \begin{lstlisting}[language=Java]
    public boolean isPositive(int number) {
        boolean result = false;
        if (number >= 0) {
            result = true;
        }
        return result;
    }
    \end{lstlisting}
\end{figure}
The test cases provided are:
\begin{enumerate}
    \item \textbf{INPUT}: number=20; \textbf{EXPECTED OUTPUT}: true
    \item \textbf{INPUT}: number=0; \textbf{EXPECTED OUTPUT}: true
\end{enumerate}
The mutants provided are:
\begin{enumerate}
    \item \textbf{Change line 3}: change \texttt{>=} with \texttt{>};
    \item \textbf{Change line 3}: change \texttt{>=} with \texttt{False};
    \item \textbf{Change line 6}: change \texttt{result} with \texttt{!result};
\end{enumerate}
We can now evaluate each mutant against the test cases to determine if they are killed.
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        Mutant & Test Case 1 & Test Case 2 & Killed \\
        \hline
        1 & true & false & Yes \\
        \hline
        2 & false & false & Yes \\
        \hline
        3 & false & false & Yes \\
        \hline
    \end{tabular}
    \caption{Mutant evaluation against test cases}
\end{table}
We can see that all three mutants are killed by the provided test cases. The mutation score can be calculated as:
\[\text{Mutation Score} = \frac{\text{Killed Mutants}}{\text{Total Mutants}} \cdot 100 = \frac{3}{3} \cdot 100 = 100\%\]