\section{Introduction}
Before starting to analyze the different types of \textbf{software vulnerabilities} and the related \textbf{testing techniques}, it's important to define some \textbf{basic concepts} and \textbf{terminology} that will be used throughout the document.
\subsection{Definitions}
\begin{definitions}
    \item[Software:] software can be defined as a set of \textbf{programs} and \textbf{data}, that provides \textbf{functionality}. Software and functionality always come with certain risks.
    \item[Security:] managing the risks introduced by software. This includes \textbf{understanding} and \textbf{identifying} security risks, and how to \textbf{mitigate them}.
    \item[Secure software:] a software is \textbf{considered secure} if it satisfies a series of security objectives, such as:
    \begin{itemize}
        \item \textbf{Confidentiality}: \textbf{unauthorized users} cannot \textbf{have access} or read information;
    
        \item \textbf{Integrity}: \textbf{unauthorized users} cannot \textbf{change} the information;

        \item \textbf{Availability}: \textbf{authorized users} can always have access to the information.
    \end{itemize}
    There are many other security objectives. Each software doesn't have to implement each of them, but it's useful to find a good \textbf{trade-off} between \textbf{security} and \textbf{functionality}.
    \item[Safety vs Security:] there's a slight difference between the two definitions, that is important to denote:
    \begin{itemize}
        \item \textbf{Safety}: protecting the system from \textbf{accidental risks};
        \item \textbf{Security}: \textbf{mitigating} the risk of danger caused by \textbf{intentional} or \textbf{malicious actions}.
        If a software does not achieve the security requirements, it can lead to security failures.
    \end{itemize}
    \item[Weakness:] a condition in a software (bug) that, under certain circumstances, could contribute to the introduction of vulnerabilities.

    \item[Vulnerability:] a chain of \textbf{weaknesses} linked by causality. If \textbf{exploited}, this can lead to a \textbf{security failure}.

    \item[Security risk:] refers to the \textbf{probability} that a threat (any external actor) will \textbf{exploit a vulnerability}, combined with the \textbf{resulting impact} (damage).

    \item[CWE:] \textbf{Common Weakness Enumeration}, provides a \textbf{public list} of the most common software and hardware \textbf{weaknesses} that can contribute to security vulnerabilities.

    \item [CVE:] \textbf{Common Vulnerabilities and Exposure}, is a public list of \textbf{vulnerabilities} in widely-used software components.
    
    \item [NVD:] \textbf{National Vulnerability Database}, public available database of CVEs. It provides additional information, such as \textbf{severity scores} and \textbf{impact ratings}.
\end{definitions}

\subsection{Bug Exploitation}
A \textbf{bug} is an error in the software code that can lead to unexpected behavior. An \textbf{attacker} will try to \textbf{exploit} a bug to make
the software behave in an unintended way, to achieve its malicious goals.
To achieve its goals, the attacker may need several exploits, chained together, composing an \textbf{attack path}.

\subsection{Security Meta-Model}
In the context of software security, a meta-model can be defined to represent the relationships between different security concepts, such as vulnerabilities, threats, and attacks. 
This meta-model can help security professionals understand the attack surface of a system and identify potential weaknesses.
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{../../images/securityMetaModel.png}
    \caption{Security Meta-Model}
\end{figure}

\subsection{Software Development Life Cycle}
The \textbf{SDLC} is the series of \textbf{processes} and \textbf{procedures} that enables teams to \textbf{create software} and applications. The cycle is composed of various phases:
\begin{itemize}
    \item \textbf{Planning}: the senior members of the team, with the inputs from the customers, \textbf{plans} the basic \textbf{project plan};
    \item \textbf{Defining}: during this phase, the document for the \textbf{product requirements} should be defined;
    \item \textbf{Designing}: designing the architecture for the whole project;
    \item \textbf{Building}: generating the programming code. The output should be the working final system;
    \item \textbf{Testing}: during this phase, products defects are reported, tracked and fixed;
    \item \textbf{Deployment}: the final release. Feedback from the users is usually collected, to better the software.
\end{itemize}

\subsubsection{From a security perspective}
Now, we are going to analyze, from a \textbf{security perspective}, what should be done by a team during each of the just mentioned phases.
\paragraph{Planning:}
During this phase, the \textbf{security objectives} required by the software should be defined. The organization should also identify the regulations it needs to follow. 

\paragraph{Defining:}
This phase is composed of three main activities:

\begin{itemize}
    \item \textbf{Gap Analysis}: identify whether there is a need to provide training sessions (security and security awareness training) for the developers involved in the project;
    \item \textbf{Risk Assessment}: analyze potential threats and vulnerabilities, and evaluate their possible impact on the project;
    \item \textbf{Third-party software tracking}: a list containing both open-source and commercial \textbf{third-party software} must be defined. This allows the team to check the used software for updates and security patches.
\end{itemize}

\paragraph{Designing:}
\begin{itemize}
    \item \textbf{Least-privilege principle}: the program should always run on the account with the least privilege possible;
    \item \textbf{Deny by default}: each access should be denied by default, unless explicitly allowed.
    \item \textbf{Design Review}: the developer has to act as an attacker to discover vulnerabilities in the defined features.
\end{itemize}

\paragraph{Building:}
\subparagraph{Security guidelines:}
While the project is being built, is always important to follow the security guidelines, such as:
\begin{itemize}
    \item Always validate and check the input data and memory;
    \item Check the command line arguments;
    \item Use external files to protect passwords;
    \item Deal with errors and exception;
    \item Avoid the creation of files when possible. Otherwise, be caution when handling them.
\end{itemize}
There are some frameworks, such as \textbf{OWASP} that can help in the secure coding rule knowledge.

\subparagraph{Code review:} conducted by a team of developers, that manually checks the code, focusing on implementation bugs. Usually, a checklist is used for checking secure coding.

\subparagraph{Security Testing:} mainly composed of two isolated phases:
\begin{itemize}
    \item \textbf{Static Analysis}: tries to identify weaknesses, without executing the program;
    \item \textbf{Vulnerability Scanning}: injection of malicious inputs in the program, to identify vulnerabilities.
\end{itemize}

\paragraph{Testing:}
Testing is suggested to be done throughout the whole development process, to identify bugs as soon as possible.
Different types of tests are usually run, such as:
\begin{itemize}
    \item \textbf{Dynamic Analysis}: identifies weaknesses by running software;
    \item \textbf{Fuzzing}: involves giving random data to a program. It helps in finding bugs that humans often miss;
    \item \textbf{Third-party penetration testing}: an attack simulation on the third-party software, with the intention to discover configuration flaws and vulnerabilities
\end{itemize}
Regardless, bugs should always be fixed ASAP, to reduce the cost of fixing them.

\subsubsection{DevOps}
The \textbf{DevOps} cycle is based on two main ideas: \textbf{rapid delivery} of new software and \textbf{quick feedback}. 
Developers continuously deliver new features in a short time span, based on 8 phases.
Developers regularly merge their code changes in a central repository (CI \textit{Continuous Integration}), where it gets automatically built, tested, and prepared for a release to production (CD \textit{Continuous Delivery}).