\section{Overflow}

\subsection{Introduction}
\label{introduction-to-overflow}
The memory of a process is divided into several distinct areas, each serving a specific purpose for data storage and program execution. It can be generally divided as follows:
\begin{itemize}
    \item \textbf{Reserved memory area}: contains the machine instructions and data reserved for the operating system;
    \item \textbf{Text area}: stores the assembly instructions of the program currently being executed;
    \item \textbf{Static data area}: contains global and static variables declared in the program;
    \item \textbf{Heap}: a dynamic memory area, managed by the developer. It contains dynamically allocated data and variables created during runtime;
    \item \textbf{Stack}: keeps track of active functions, their parameters, return addresses, and local variables.
\end{itemize}

\subsection{Buffer Overflow}
A \textbf{buffer overflow} occurs when a program attempts to write more data into a fixed-length memory buffer than it can hold.
\\Since user data and control flow information are mixed together in the memory, the user data exceeding a buffer may corrupt other data and control flow information.

\paragraph{Spotting buffer overflow:} The following conditions frequently lead to buffer overflow vulnerabilities:
\begin{itemize}
    \item input originates from untrusted sources (network, files, or command line);
    \item the input is copied or transferred into internal structures such as fixed-size buffers;
    \item data or strings are manipulated using \textbf{unsafe functions} that do not perform bounds checking (for example: \texttt{strcpy}, \texttt{strcat}, \texttt{gets}).
\end{itemize}
Vulnerabilities of this kind can be detected using dynamic testing techniques such as fuzzing.

\paragraph{Fixing buffer overflow:}
When working with strings, always use safe versions of the needed functions, that take into account the count of characters to work on. Always check loop termination and array boundaries.

\subsection{String format vulnerabilities}
A \textbf{non-verified string} used as a format string may allow an attacker
to inject format specifiers (for example \texttt{\%s}, \texttt{\%x}) that read values
from the stack. This becomes possible when a formatting function accepts a
variable number of arguments (ellipsis), e.g.
\begin{verbatim}
    int printf(const char *format, ...);
\end{verbatim}
Passing untrusted input directly as the \texttt{format} parameter is unsafe because
the attacker can control how the function interprets stack contents.

\paragraph{Fixing string formats:} always sanitize user input before using it as a format string. Use constant strings whenever possible and avoid the use of unsafe functions, such as 
\begin{verb} 
printf();
\end{verb}
\subsection{Integer overflow}
\paragraph{2's complement notation:}
Integers are usually represented using the \textbf{two's complement} notation.  
Given a sequence of $n$ bits, the representable range of values is:
\[
[-2^{n-1}, 2^{n-1}-1]
\]
This means that, when working with signed integers, exceeding the upper or lower
limit of this range causes the value to \textbf{wrap around} to the opposite side
of the range.

\paragraph{Example:}
For an 8-bit signed integer:
\[
[-128, 127]
\]
Adding $1$ to $127$ results in $-128$:
\[
127 + 1 = -128
\]
Similarly, subtracting $1$ from $-128$ results in $127$.

\paragraph{Causes and risks:}
Integer overflow occurs when an arithmetic operation produces a value outside
the representable range of the integer type.  
In C and C-like languages, this can happen due to:
\begin{itemize}
    \item arithmetic operations (\texttt{+}, \texttt{-}, \texttt{*});
    \item insufficient range checking on user-controlled input (e.g., array indices, buffer sizes, loop counters).
\end{itemize}

\paragraph{Fix integer overflow:}
\begin{itemize}
    \item Use sufficiently large integer types (\textbf{short} = 16 bits, \textbf{int} = 32 bits, \textbf{long} = 64 bits);
    \item Explicitly check arithmetic operations that may exceed type limits, by comparing with data type limit;
\end{itemize}

\subsection{Heap overflow}
As described in Chapter \ref{introduction-to-overflow}, the heap is a dynamic
memory area managed at runtime. Incorrect use can cause \textbf{heap overflows},
which may crash the application or corrupt heap metadata. This can happen when:
\begin{itemize}
    \item allocating excessively large buffers without validating sizes;
    \item repeatedly allocating memory and failing to free it (memory leaks) combined with unchecked writes;
    \item writing beyond the bounds of a dynamically allocated buffer (off-by-one, missing length checks).
\end{itemize}

\subsection{Final remarks and barriers}
\paragraph{Base attack pattern:} usually \textbf{overflow-based} attacks follow these steps:
\begin{enumerate}
    \item \textbf{Inject attack code} into the buffer. Code that is already in the program can be used or otherwise, code can be injected;
    \item \textbf{Redirect control flow} to the injected code. This way the execution jumps to the malicious code;
    \item \textbf{Execute} the attack code.
\end{enumerate}
\paragraph{Barriers to exploitation:} there are 4 main approaches to barriers the exploitation of this vulnerability:
\begin{itemize}
    \item \textbf{Address space} layout randomization: use a form of randomization to store data in the memory. This way, we cannot know the location of certain functions;
    \item \textbf{Canaries}: fixed-byte known values, placed between a buffer and control data on the stack. This way, when the buffer overflows, the first data to be corrupted will be this fixed data, alerting of the overflow;
    \item \textbf{Executable space protection (ESP)}: marks regions as non-executable. Any attempt to execute machine code in these regions will cause an exception;
    \item \textbf{testing}: fuzzing and static analysis can be used to detect this type of vulnerability.
\end{itemize}