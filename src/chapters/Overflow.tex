\section{Overflow}
To understand overflow vulnerabilities, it is important to have a basic understanding of how memory is organized in a running process.
\subsection{Introduction}
\label{introduction-to-overflow}
The memory of a process is divided into several distinct areas, each serving a specific purpose for data storage and program execution. It can be generally divided as follows:
\begin{itemize}
    \item \textbf{Reserved memory area}: contains the machine instructions and data reserved for the operating system;
    \item \textbf{Text area}: stores the assembly instructions of the program currently being executed;
    \item \textbf{Static data area}: contains global and static variables declared in the program;
    \item \textbf{Heap}: a dynamic memory area, managed by the developer. It contains dynamically allocated data and variables created during runtime;
    \item \textbf{Stack}: keeps track of active functions, their parameters, return addresses, and local variables.
\end{itemize}

\subsection{Buffer Overflow}
A buffer overflow occurs when a program attempts to write more data into a fixed-length memory buffer than it can hold.
\\Since user data and control flow information are mixed together in the memory, the user data exceeding a buffer may corrupt other data and control flow information.

\paragraph{Spotting buffer overflow:} The following conditions frequently lead to buffer overflow vulnerabilities:
\begin{itemize}
    \item input originates from untrusted sources (network, files, or command line);
    \item the input is copied or transferred into internal structures with a fixed size;
    \item data or strings are manipulated using unsafe functions that do not perform bounds checking (for example: \texttt{strcpy}, \texttt{strcat}, \texttt{gets}).
\end{itemize}
Vulnerabilities of this kind can be detected using dynamic testing techniques such as fuzzing.

\paragraph{Fixing buffer overflow:}
When working with strings, always use safe versions of the needed functions, that take into account the count of characters to work on. 
Always check loop termination and array boundaries.

\subsection{String format vulnerabilities}
A non-validated string may be used as a \textit{format string} in certain functions (e.g., \texttt{printf} in C/C++).
If an attacker can insert format specifiers (like \texttt{\%x}, \texttt{\%s}, \texttt{\%n}) into the string, they can read or write arbitrary memory locations.
This is possible if the formatting option has an undeclared number of arguments, such as in the function:
\begin{verbatim}
    int printf(const char *format, ...);
\end{verbatim}
Passing untrusted input directly as the \texttt{format} parameter is unsafe because
the attacker can control how the function interprets stack contents.
\paragraph{Example:}
Consider the following C code snippet:
\begin{lstlisting}[language=C]
#include <stdio.h>
int main() {
    char user_input[100];
    printf("Enter a string: ");
    gets(user_input);
    printf(user_input); // Vulnerable to format string attack
    return 0;
}
\end{lstlisting}
If an attacker inputs the string \verb|"%x %x %x %x"|, the program will print out four values from the stack, potentially revealing sensitive information.

\paragraph{Fixing string formats:} 
always sanitize user input before using it as a format string. 
Use constant strings whenever possible and avoid the use of unsafe functions, such as \texttt{printf()}.

\subsection{Integer overflow}
To understand integer overflow, it is important to know how integers are represented in computer memory.
\paragraph{Integer Representation - 2's complement notation:}
To allow positive and negative values, integers are usually represented using the \textit{two's complement notation}.
It is a binary representation where the \textit{Most Significant Bit} (MSB) indicates the sign of the integer (0 for positive, 1 for negative).
Given a sequence of $n$ bits, the representable range of values is:
\[
[-2^{n-1}, +2^{n-1}-1]
\]
When working with signed integers using this representation, exceeding the upper or lower limit of this range causes the MSB value to change. 
This results in the value wrapping around to the opposite side of the range.

\paragraph{Example:}
For an 8-bit signed integer:
\[
[-128, 127]
\]
Adding $1$ to $127$ results in $-128$:
\[
127 + 1 =
01111111 + 00000001 = 10000000 = -128
\]
Similarly, subtracting $1$ from $-128$ results in $127$:

\paragraph{Causes and risks:}
Integer overflow occurs when an arithmetic operation produces a value outside
the representable range of the integer type.  
In C and C-like languages, this can happen due to:
\begin{itemize}
    \item arithmetic operations (\texttt{+}, \texttt{-}, \texttt{*});
    \item insufficient range checking on user-controlled input (e.g., array indices, buffer sizes, loop counters).
\end{itemize}

\paragraph{Fix integer overflow:}
\begin{itemize}
    \item Use sufficiently large integer types (\textit{short} = 16 bits, \textit{int} = 32 bits, \textit{long} = 64 bits);
    \item Explicitly check arithmetic operations that may exceed type limits, by comparing with data type limit;
\end{itemize}

\subsection{Heap overflow}
As described in Chapter \ref{introduction-to-overflow}, the heap is a dynamic
memory area managed at runtime. Incorrect use can cause heap overflows,
which may crash the application or corrupt heap metadata. This can happen when:
\begin{itemize}
    \item allocating excessively large buffers without validating sizes;
    \item repeatedly allocating memory and failing to free it (memory leaks) combined with unchecked writes;
    \item writing beyond the bounds of a dynamically allocated buffer (off-by-one, missing length checks).
\end{itemize}

\subsection{Final remarks and barriers}
\paragraph{Base attack pattern:} usually overflow-based attacks follow these steps:
\begin{enumerate}
    \item \textbf{Inject attack code} into the buffer. Code that is already in the program can be used or otherwise, code can be injected;
    \item \textbf{Redirect control flow} to the injected code. This way the execution jumps to the malicious code;
    \item \textbf{Execute} the attack code.
\end{enumerate}
\paragraph{Barriers to exploitation:} there are 4 main approaches to barriers the exploitation of this vulnerability:
\begin{itemize}
    \item \textbf{Address space} layout randomization: use a form of randomization to store data in the memory. This way, we cannot know the location of certain functions;
    \item \textbf{Canaries}: fixed-byte known values, placed between a buffer and control data on the stack. This way, when the buffer overflows, the first data to be corrupted will be this fixed data, alerting of the overflow;
    \item \textbf{Executable space protection (ESP)}: marks regions as non-executable. Any attempt to execute machine code in these regions will cause an exception;
    \item \textbf{testing}: fuzzing and static analysis can be used to detect this type of vulnerability.
\end{itemize}