\section{Taint Analysis}
Taint analysis is one possible solution of the data-flow analysis problem. 
It aims to track the flow of sensitive information through a program and identify potential security vulnerabilities.
\\To understand how taint analysis works, we need to define some concepts:
\begin{itemize}
    \item \textbf{Tainted Variable}: a variable is considered tainted if it contains data from an untrusted source (for example, user input), and has not yet been sanitized or validated. 
    \item \textbf{Untainted Variable}: a variable is considered untainted if it contains data that has been properly sanitized or validated;
\end{itemize}
It's important to ensure that tainted variables should never be used in security-critical statements (such as system calls, database queries, file operations).
There are two main types of taint analysis:
\begin{itemize}
    \item \textbf{Static taint analysis:} analyzes the program's source code without executing it, to identify potential taint flows and vulnerabilities. It's conducted on the Control Flow Graph (CFG) of the program;
    \item \textbf{Dynamic taint analysis:} tracks the flow of tainted variables during program execution, allowing for more precise detection of vulnerabilities in real-time.
\end{itemize}

\subsection{Static taint analysis}
Before diving into the implementation of static taint analysis, we need to define some key concepts:
\begin{itemize}
    \item \textbf{Source}: a source is the point of the program where a tainted variable is defined. This could be user input, data read from a file, or any other untrusted data.
    \item \textbf{Sink}: a sink is the point of the program where a tainted variable is used in a potentially dangerous way, such as being passed to a system call or used in a database query. The possible sinks can differ based on the application context and on the vulnerability we want to detect.
    \item \textbf{Taint propagation rules}: specify the taint status for data derived from tainted/untainted operand.
    \item \textbf{Sanitization}: the operation conducted on a tainted variable to check / sanitize it.
\end{itemize}
The goal of static taint analysis is, for all possible inputs, to prove that the tainted data will never be used where untainted data is expected.
The solution requires to analize all the possible data flow of the program. This is done following these steps:
\begin{enumerate}
    \item Identify all possible \textbf{sources} in the program;
    \item Identify all possible \textbf{sinks} in the program;
    \item Identify and analyze all possible data flows in which sources can reach sinks;
    \item Identify whether a tainted source flows into a security-critical sink.
\end{enumerate}
Since we want to analyze all possible data flows, static taint analysis is usually implemented using data flow analysis techniques.
\subsubsection{How to implement taint analysis}
Static Taint Analysis can be implemented by customizing the data flow analysis framework.
\begin{itemize}
    \item \textbf{Taint status:} the taint status of a variable can be either \textbf{true} (tainted) or \textbf{false} (untainted). It is expressed as:
    $x \rightarrow \{T, F\}$;
    \item \textbf{Flow information:} the flow information propagated for taint analysis consists of taint sets. Formally:
    $ V = \mathcal{P}(X)$;
    where $X$ is the set of all variables in the program, and $\mathcal{P}(X)$ is the permutation set of $X$;
    \item \textbf{Meet operator:} at a join point, the taint status of a variable is tainted if it is tainted along at least one incoming path. 
    The meet operator is therefore the union of the taint sets of its predecessors. Formally:
    \[In(n) = \bigcup_{p\in pred(n)} Out(p)\]
    \item \textbf{Transfer function:} the transfer function for taint analysis has the form:
    \[f_n(x) = Gen[n] \cup (x \setminus Kill[n])\]
    where:
    \begin{itemize}
        \item $x$: a var $\in In(n)$;
        \item $Gen[n]$: the set of variables that are tainted at node $n$. It's formally defined as:
        \[Gen[n] = \{x \in X | x \text{ is assigned an input value at statement } n\} \]
        \[\cup\]
        \[\{x \in X |\exists y \in X: x \text{ is assigned a value obtained from }y \wedge  y \rightarrow T\}  \]
        This means that, at a statement $n$, a variable $x$ is considered tainted if it is directly assigned a value from an untrusted source or if it is derived from another tainted variable $y$.
        \item $Kill[n]$: the set of variables that are untainted at node $n$. It's formally defined as:
        \[Kill[n] = \{x \in X | x \text{ is sanitized at statement } n\} \]
        \[\cup\]
        \[\{x \in X |\forall y \in X: x \text{ is assigned a value obtained from }y \wedge  y \rightarrow F\}  \]
        This means that, at a statement $n$, a variable $x$ is considered untainted if it is sanitized or if it is derived solely from untainted variables.
    \end{itemize}
\end{itemize}
For example, consider the following code snippet:
\begin{lstlisting}[language=Python]
def foo:
    y = 5
    x = input() 
    x = check(x)
    z = x + y
    return z
\end{lstlisting}
We can say that:
\begin{itemize}
    \item at line 2, variable \texttt{x} is tainted because it receives data from an untrusted source (user input);
    \item at line 3, variable \texttt{x} is untainted because it is sanitized by the function \texttt{check()};
    \item at line 4, variable \texttt{z} is also untainted because it is derived from two untainted variables (\texttt{x} and \texttt{y}).
\end{itemize}
\subsubsection{Algorithm}
The algorithm for static taint analysis can be summarized as follows:
\begin{algorithm}
\caption{Static Taint Analysis Algorithm}
\begin{algorithmic}[1]
\ForAll{node $n$}
    \State init Gen[n]
    \State init Kill[n]
\EndFor
\Repeat
    \ForAll{node $n$}
        \State $In[n] = \cup_{p\in pred(n)}Out(p)$
        \State $Out[n] = Gen[n] \cup (In[n] \setminus Kill[n])$
    \EndFor
\Until{no changes in any $In(n)$ or $Out(n)$}
\end{algorithmic}
\end{algorithm}
The algorithm initializes the \textbf{Gen} and \textbf{Kill} sets for each node in the CFG. It then iteratively computes the \textbf{In} and \textbf{Out} sets for each node until no further changes occur.
At the end of the analysis, we can check if any tainted variable reaches a sink without being sanitized, indicating a potential security vulnerability.

\subsubsection{Limitations}
Static taint analysis has some limitations:
\begin{itemize}
    \item \textbf{False positives:} the analysis may report vulnerabilities that do not actually exist in the program, due to overtainting;
    \item \textbf{Hard implementation:} implementing a precise and efficient static taint analysis can be complex, especially for large codebases with intricate control flows;
    \item we do not know what actual value might cause the vulnerability to be exploited.
\end{itemize}
\subsection{Dynamic taint analysis}
Dynamic taint analysis tries to overcome some of the limitations of static taint analysis by tracking tainted variables during program execution.
\begin{itemize}
    \item \textbf{Traces}: flow of data through the program;
    \item \textbf{Taint sources}: points where tainted data is introduced into the program;
    \item \textbf{Taint propagation}: how taint status is transferred between variables during execution;
    \item \textbf{Sinks}: points where tainted data is used in a potentially dangerous way.
\end{itemize}
Code instrumentation is usually used to implement dynamic taint analysis. It consists in modifying the program code to insert additional instructions that track the taint status of variables during execution.
This type of instrumentation can be done at different levels:
\begin{itemize}
    \item \textbf{Source code level:} modify the source code of the application;
    \item \textbf{Binary level:} modify the compiled binary code of the application;
    \item \textbf{Runtime level:} use a runtime environment that supports taint tracking.
\end{itemize}
The higher the level, the more information is available for taint tracking.
