\section{Dynamic Analysis}
Dynamic analysis is a software verification technique that involves executing the program and observing its behavior.
There are two main strategies to perform dynamic analysis:
\begin{itemize}
    \item \textbf{Testing}: executing the program with specific inputs and checking the outputs against expected results;
    \item \textbf{Fuzzing}: generating random or semi-random inputs to the program and observing its behavior for crashes or unexpected outputs;
\end{itemize}
\subsection{Testing}
We can differentiate between two main types of testing:
\begin{itemize}
    \item \textbf{Testing}: verifies the functionality of the software against sensible inputs and border cases. It checks that functionalities work as expected;
    \item \textbf{Security testing}: looks for wrong, unwanted and strange behaviors of the software that could lead to vulnerabilities and security issues.
\end{itemize}
As we said before, testing involves executing the program with specific inputs and checking the outputs against expected results.
A \textbf{test suite} is a collection of test cases that are intended to be executed together to validate the behavior of a software application.
Each \textbf{test case} is composed of a test input and an expected output, which is used to verify the correctness of the software's behavior.
\\\\When designing a test suite, several key questions need to be addressed:
\begin{itemize}
    \item How to \textbf{identify} the \textbf{test cases}?
    \item How to identify the \textbf{test oracle}?
    \item When to \textbf{stop testing}?
\end{itemize}

\subsubsection{Test coverage criteria}
Tipically, for a tested software, there are an infinite number of possible inputs and execution paths. This makes it impossible to test all possible scenarios.
\\A \textit{test coverage criterion} defines a set of requirements that a test suite must satisfy to be considered adequate.
It aims at insuring that a test suite is comprehensive enough and that all relevant and critical application 
aspects and functionality are covered.
\\Test coverage criteria can:
\begin{itemize}
    \item \textbf{Increase test effectiveness}: helps insuring that the test suite covers a wide range of scenarios and edge cases;
    \item \textbf{Remove redundant tests}: can identify and eliminate redundant tests that do not contribute to the overall coverage;
    \item \textbf{Discover uncovered areas}: can highlight areas of the code that are not covered by existing test suites;
    \item \textbf{Improve regression testing}: can help ensure that changes to the code do not introduce new bugs or vulnerabilities.
\end{itemize}

Several test coverage criteria exist, each focusing on different aspects of the software. 
We will mainly focus on \textbf{code coverage criteria}. It measures how much of the application source code is executed during testing.
Several code criteria exist:
\begin{itemize}
    \item \textbf{Statement coverage}: ensures that each statement in the code is executed
    \item \textbf{Branch coverage}: ensures that each branch of control structures (like if-else statements) is executed
    \item \textbf{Decision coverage}: ensures that each decision point (like conditions in if statements) is evaluated to both true and false
    \item \textbf{Condition coverage}: ensures that each individual condition in a decision point is evaluated to both true and false
\end{itemize}
We first havw to introduce a few definitions:
\begin{itemize}
    \item \textbf{Coverage}: the percentage of code elements (statements, branches, etc.) that have been executed during a single test case;
    \item \textbf{Test suite coverage}: measures how effectively a set of test cases covers the codebase. It can be computed in different ways:
    \begin{itemize}
        \item \textbf{Total suite coverage}(TSC): obtained by aggregating the coverage achieved by all test cases in the suite;
        \item \textbf{Additional suite coverage}(ASC): consider the incremental coverage provided by each test case. Starting from the case with 
        covers the largest number of new elements, add subsets based on the number of new elements they cover.
    \end{itemize}
\end{itemize}
We can now describe the different code coverage criteria.
\subsubsection*{Statement coverage criteria}
Statement coverage aims at involving the execution of \textbf{all possible statements} in the code at least once during testing.
It can be defined as:
\[\text{coverage}=\frac{\text{\#executed statements}}{\text{\#total statements}} \cdot 100\]
The goal is to identify test cases that covers different portion of the code. 
We need to design test cases that exercise different portions of the code.
\\\\Considering the whole suite, we can define:
\[\text{TSC}=\frac{\text{covered statement}}{\text{total statements}} \cdot 100\]
Given the previous example, we can see that test case 2 covers no new statements compared to test case 1, so it can be removed from the suite.

\subsubsection*{Decision coverage criteria}
Decision coverage aims at ensuring that \textbf{the possible outcomes of all boolean expressions} are executed at least once during testing.
It can be defined as:
\[\text{coverage}=\frac{\text{executed decision outcomes}}{\text{total decision outcomes}} \cdot 100\]
For example, consider the previous code snippet
To fully cover all decision outcomes, test cases must be designed to evaluate each boolean expression to both true and false.
\\\\Considering the whole suite, we can define:
\[\text{TSC}=\frac{\text{covered decision}}{\text{total decision}} \cdot 100\]

\subsubsection*{Condition coverage criteria}
Similar to decision coverage, condition coverage focuses on ensuring that \textbf{each individual condition} within a decision point is evaluated to both true and false at least once during testing.
It can be defined as:
\[\text{coverage}=\frac{\text{executed condition outcomes}}{\text{total condition outcomes}} \cdot 100\]
\\\\Considering the whole suite, we can define:
\[\text{TSC}=\frac{\text{covered condition}}{\text{total condition}} \cdot 100\]

\subsubsection*{Branch coverage criteria}
Branch coverage aims at ensuring that \textbf{all possible branches} of control structures are executed. 
To ensure this, it checks that every possible edge in the control flow graph is traversed during testing.
It can be defined as:
\[\text{coverage}=\frac{\text{executed branches}}{\text{total branches}} \cdot 100\]
\\\\Considering the whole suite, we can define:
\[\text{TSC}=\frac{\text{covered branches}}{\text{total branches}} \cdot 100\]

\subsubsection{Mutation testing}
The goal of \textit{mutation testing} is to evaluate the effectiveness of a test suite in discovering real faults in the software.  
It involves creating \textit{mutants} of the original program by introducing small changes (mutations) to its code.
\\\\The process of mutation testing can be summarized in the following steps:
\begin{enumerate}
    \item \textbf{Mutant generation:} create a set of mutants by applying mutation operators to the original program. 
    Each mutant should differ from the original program by a small single change. The code must still compile and run after the mutation;
    \item \textbf{Test execution:} run the existing test suite against each mutant. Record whether the test suite detects the mutation;
    \item \textbf{Mutant analysis:} analyze the results of the test executions to determine which mutants were "killed" (detected by the test suite) and which survived (not detected);
\end{enumerate}
The effectiveness of the test suite can be measured using the \textbf{mutation score}:
\[\text{Mutation Score}=\frac{\text{\#Killed Mutants}}{\text{\#Total Mutants}} \cdot 100\]
We say that a test suite is \textbf{mutation adequate} if it achieves 100\% mutation score.

\subsection{Fuzzing}
Fuzzing is a \textbf{highly effective} and \textbf{automated} security testing technique.
It involves generating \textbf{random or semi-random inputs} to a program and check for crashes, memory leaks, or unexpected behavior.
Some examples of test inputs are:
\begin{itemize}
    \item Very \textbf{long} or \textbf{empty} strings;
    \item \textbf{min / max} values for numeric inputs, zero or negative numbers;
    \item \textbf{Malformed} data structures or files;
    \item \textbf{Unexpected} sequences of inputs or commands, usually specific to the application domain.
\end{itemize}
\subsubsection{Types of Fuzzing}
\begin{itemize}
    \item \textbf{Dump fuzzing}: fuzzing that does not consider the context and state of the software.
    It focuses on generating random inputs without any knowledge, fed directly to the program and observing its behavior.
    \item \textbf{Smart fuzzing}: generates inputs based on a predefined model, using a degree of understanding of the target application.
    This approach aims to create \textbf{valid} inputs that conform to the expected structure of the application, taking into account also the code coverage.
    Examples of algorithm used for generating inputs are:
    \begin{itemize}
        \item \textbf{Random};
        \item \textbf{Template / Grammar}: follows specific templates or grammars to generate inputs that conform to expected formats;
        \item \textbf{Guided}: the input generation is guided by feedback from previous test executions, such as code coverage information or execution paths taken by the program;
        \item \textbf{Mutation based}: starts with a set of valid inputs and applies mutations to create new test cases;
        \item \textbf{Generation based}: creates inputs from scratch based on a model of the input space.
    \end{itemize}
\end{itemize}
\subsubsection{Pros and cons of Fuzzing}
\begin{itemize}
    \item \textbf{Pros}:
    \begin{itemize}
        \item Can discover unknown vulnerabilities and give insights into the robustness of the software;
        \item Automated and scalable. With minimal human effort it can generate a large number of test cases;
    \end{itemize}
    \item \textbf{Cons}:
    \begin{itemize}
        \item Fuzzers don't guarantee full coverage of the codebase;
        \item Crashes may be hard to reproduce and debug;
        \item For programs with complex input formats, generating valid inputs and achieving good coverage can be challenging.
    \end{itemize}
\end{itemize}
